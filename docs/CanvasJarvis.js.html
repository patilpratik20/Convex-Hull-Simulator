<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CanvasJarvis.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CanvasJarvis.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* The above code is a JavaScript file that appears to be related to a canvas drawing application using
React. Here is a summary of what the code is doing: */
// Canvas.js


import React, { useRef, useEffect, useState } from 'react';
import './Canvas.css';
import p_ope from './p_right_open.png';
import p_clos from './p_right_close.png';
import cyan_ from './cyan_ghost.png';
import afraid_ from './afraid_ghost.png';

import greenright from './greenright1.png';

import point_added from './point_added.mp3';
import pacman_chomp from './pacman_chomp.wav';
import pacmna_death from './pacman_death.wav';
import pacman_extrapac from './pacman_extrapac.wav';
import pacman_intermission from './pacman_intermission.wav';
import state_change from './retro-video-game-coin-pickup-38299.mp3';
import siren from './siren.mp3';
import pinkright from './pinkright1.png';
import redright from './redright1.png';
import orangeright from './yellowright1.png';

var ctx;
var canvas;
var currentPoints = [];
var indexOfGhosts = [];

// output
var myConvexHull = []; // outputIndex, points, pairs, pairs, state
var outputindex = 0;
var p_close = new Image();
// p_close_first.src = "./p_right_close.png";
p_close.src = p_clos;
// // p_close.onload = () => {
// // };
var p_open = new Image();
// p_open_first.src = "./p_right_open.png";
p_open.src = p_ope;
var cyan_g = new Image();
// cyan_g_first.src = "./cyan_ghost.png";
cyan_g.src = cyan_;
var afraid_g = new Image();
// afraid_g_first.src = "./afraid_ghost.png";
afraid_g.src = afraid_;
var p_size = 25;
var ghostSize = 20;
var ghostList = [];
var ghostList_in_next = [];
var pacman;
var list1 = [];
var list2 = [];
var hull_list = [];
var f = false;
var flag2 = false;
// var list3 = [];
var flag3 = true;
var idx = 0;
var flag_done_ch = false;

let req1;
let req2;
var textBoxEle = [];

/**
 * The Pacman function in JavaScript defines a class for controlling the movement and drawing of a
 * Pacman character on a canvas, including handling orientation, speed reduction, and drawing
 * animations.
 * @param non_hull - The `non_hull` parameter in the `Pacman` function represents a list of points that
 * Pacman will move through. These points define the path that Pacman will follow on the canvas. Each
 * point in the list has an `x` and `y` coordinate representing its position.
 * @param img_open - The `img_open` parameter in the `Pacman` function represents the image that will
 * be displayed when Pacman's mouth is open. This image is used to visually represent Pacman in the
 * game.
 * @param img_close - The `img_close` parameter in the `Pacman` function is used to specify the image
 * that will be displayed when the Pacman character is in a closed mouth state. This image is typically
 * used to represent the Pacman character when it is not actively eating or moving.
 * @param size - The `size` parameter in the Pacman function represents the size of the Pacman
 * character. It is used to determine the dimensions of the Pacman image that will be displayed on the
 * canvas. The `size` parameter is typically a numerical value that specifies the width and height of
 * the Pacman character
 * @returns The code provided defines a constructor function `Pacman` that creates instances of a
 * Pacman object. The Pacman object has properties and methods related to its movement and drawing on a
 * canvas. The constructor function takes parameters such as `non_hull` (an array of points),
 * `img_open` and `img_close` (images for open and closed mouth Pacman), and `size` (
 */
function Pacman(non_hull, img_open, img_close, size) {
    this.non_hull = non_hull.slice();
    // console.log("i",list1);
    list1.reverse();
    list1.pop();
    list1.reverse();
    // console.log("Hi",list1);
    // list1 = list1.slice(1);
    this.curr_x = this.non_hull[0].x;
    this.curr_y = this.non_hull[0].y;
    this.size = size;
    if (this.non_hull.length > 1) {
        this.next_x = this.non_hull[1].x;
        this.next_y = this.non_hull[1].y;
    }
    else {
        this.next_x = this.non_hull[0].x;
        this.next_y = this.non_hull[0].y;
    }
    this.eqal_x = 0;
    if (this.curr_x === this.next_x) {
        this.eqal_x = 1;
    }
    this.image_open = img_open;
    this.image_close = img_close;
    // this.rotate_image = function(degree) {
    //     degree = (degree + 360) % 360;
    //     this.image_close.style.transform = `rotate(${degree}deg)`;
    //     this.image_open.style.transform = `rotate(${degree}deg)`;
    //     // console.log("in rotate image", degree);
    //     // console.log(`rotate(${degree}deg)`);
    // }
    this.dx = Math.sign(this.next_x - this.curr_x);
    this.slope = Math.sign(this.next_y - this.curr_y);
    if (this.curr_x !== this.next_x) {
        this.slope = (this.next_y - this.curr_y) / (this.next_x - this.curr_x);
    }
    if (this.dx !== 0) {
        this.slope = this.slope * this.dx;
    }
    // this.orientation = Math.atan(this.slope);
    if (this.curr_x === this.next_x) {
        this.orientation = Math.sign(this.next_y - this.curr_y) * Math.PI / 2;
    }
    // this.rotate_image(this.orientation * 180 / Math.PI);
    this.flag = 0;
    this.count = 0;
    this.index = 1;
    this.set_non_hull = function (non_hull) {
        this.non_hull = non_hull.slice();
        this.next_x = this.non_hull[0].x;
        this.next_y = this.non_hull[0].y;
        this.dx = Math.sign(this.next_x - this.curr_x);
        this.slope = Math.sign(this.next_y - this.curr_y);
        if (this.curr_x !== this.next_x) {
            this.slope = (this.next_y - this.curr_y) / (this.next_x - this.curr_x);
        }
        if (this.dx !== 0) {
            this.slope = this.slope * this.dx;
        }
        this.original_slope = this.slope;
        this.original_dx = this.dx;
        this.orientation = Math.atan(this.slope);
        if (this.curr_x === this.next_x) {
            this.orientation = Math.sign(this.next_y - this.curr_y) * Math.PI / 2;
        }
        this.reduce_speed();
        this.flag = 0;
        this.count = 0;
        this.index = 0;
        if (this.curr_x === this.next_x) {
            this.eqal_x = 1;
        }
        else {
            this.eqal_x = 0;
        }
    }
    this.original_slope = this.slope;
    this.original_dx = this.dx;
    this.reduce_speed = function () {
        while (this.dx >= 0.0001 &amp;&amp; (this.slope >= 2 || this.slope &lt;= -2)) {
            this.dx = this.dx / 2;
            this.slope = this.slope / 2;
        }
    }
    this.reduce_speed();
    this.get_position = function () {
        return { x: this.curr_x, y: this.curr_y };
    }

    this.draw_open = function () {
        // console.log("in draw open: ", (this.orientation + 2 * Math.PI) , this.orientation);
        ctx.save();
        ctx.translate(this.curr_x, this.curr_y);
        var deltaX = this.next_x - this.curr_x;
        var deltaY = this.next_y - this.curr_y;
        var angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(this.image_open, -this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
    }

    this.draw_close = function () {
        ctx.save();
        ctx.translate(this.curr_x, this.curr_y);
        var deltaX = this.next_x - this.curr_x;
        var deltaY = this.next_y - this.curr_y;
        var angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
        ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(this.image_close, -this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
    }

    this.draw_food = function (x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        ctx.closePath();
    }

    this.draw_hull = function () {
        ctx.lineWidth = 5;
        for (var i = 0; i &lt; hull_list.length - 1; i++) {
            ctx.beginPath();
            ctx.moveTo(hull_list[i].x, hull_list[i].y);
            ctx.lineTo(hull_list[i + 1].x, hull_list[i + 1].y);
            ctx.strokeStyle = 'black';
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.moveTo(hull_list[hull_list.length - 1].x, hull_list[hull_list.length - 1].y);
        ctx.lineTo(this.curr_x, this.curr_y);
        ctx.strokeStyle = 'black';
        ctx.stroke();
    }

    this.update = function () {
        if (f === true &amp;&amp; hull_list.length > 1) {
            this.draw_hull();
        }
        this.count++;
        this.curr_x += this.dx;
        this.curr_y += this.slope;

        if (this.eqal_x === 0) {
            if (this.curr_x !== this.next_x) {
                for (var i = this.curr_x; i !== this.next_x; i += (10 * this.original_dx)) {
                    if (Math.abs(i) &lt; canvas.width) {
                    } else {
                        break;
                    }
                    if (this.original_dx === 1 &amp;&amp; i > this.next_x) {
                        break;
                    }
                    else if (this.original_dx === -1 &amp;&amp; i &lt; this.next_x) {
                        break;
                    }
                    // this.draw_food(i, this.curr_y + (i - this.curr_x) * this.slope * this.dx);
                    this.draw_food(i, this.curr_y + (i - this.curr_x) * this.original_slope * this.original_dx);
                }
            }
            if (this.index === this.non_hull.length - 1 &amp;&amp; this.curr_x === this.next_x) {
                this.curr_x = this.next_x;
                this.curr_y = this.next_y;
                this.dx = 0;
                this.slope = 0;
                if (f === true) {
                    hull_list.push(list2[0]);
                }
                list1.reverse();
                list1.pop();
                list1.reverse();
                // list1 = list1.slice(1);
                this.draw_close();
                // console.log(points.length);
                // console.log(non_hull.length);
            }
            // else if(this.curr_x === this.next_x &amp;&amp; Math.abs(this.curr_y - this.next_y) > 1) {

            // }
            else if (this.curr_x === this.next_x) {
                this.curr_x = this.next_x;
                this.curr_y = this.next_y;
                this.next_x = this.non_hull[this.index + 1].x;
                this.next_y = this.non_hull[this.index + 1].y;
                this.dx = Math.sign(this.next_x - this.curr_x);
                this.slope = Math.sign(this.next_y - this.curr_y);
                if (this.curr_x !== this.next_x) {
                    this.slope = (this.next_y - this.curr_y) / (this.next_x - this.curr_x);
                }
                if (this.dx !== 0) {
                    this.slope = this.slope * this.dx;
                }
                this.original_slope = this.slope;
                this.original_dx = this.dx;
                this.reduce_speed();
                this.flag = 0;
                if (this.curr_x === this.next_x) {
                    this.eqal_x = 1;
                }
                else {
                    this.eqal_x = 0;
                }
                this.orientation = Math.atan(this.slope);
                if (this.curr_x === this.next_x) {
                    this.orientation = Math.sign(this.next_y - this.curr_y) * Math.PI / 2;
                }
                this.count = 0;
                this.index++;
                // points = points.slice(1);
                this.draw_close();
            }
            else if (this.flag === 0) {
                this.draw_close();
                if (this.count === 15) {
                    this.flag = 1;
                    this.count = 0;
                }
            }
            else {
                this.draw_open();
                if (this.count === 15) {
                    this.flag = 0;
                    this.count = 0;
                }
            }
            if (list1.length > 1 &amp;&amp; this.curr_x === list1[0].x) {
                if (f === true) {
                    hull_list.push(list2[0]);
                }
                list1.reverse();
                list1.pop();
                list1.reverse();
                // list1 = list1.slice(1);
                // console.log(points.length);
                // console.log(non_hull.length);
            }
        }
        else {
            if (this.curr_y !== this.next_y) {
                for (var itr = this.curr_y; itr !== this.next_y; itr += (10 * this.original_slope)) {
                    if (Math.abs(itr) > canvas.height) {
                        break;
                    }
                    if (this.original_slope === 1 &amp;&amp; itr > this.next_y) {
                        break;
                    }
                    else if (this.original_slope === -1 &amp;&amp; itr &lt; this.next_y) {
                        break;
                    }
                    this.draw_food(this.curr_x, itr);
                    // console.log("slope:", this.slope);
                    // console.log("in loop draw: ",this.curr_x, i);
                }
            }
            if (this.index === this.non_hull.length - 1 &amp;&amp; this.curr_y === this.next_y) {
                this.curr_x = this.next_x;
                this.curr_y = this.next_y;
                this.dx = 0;
                this.slope = 0;
                if (f === true) {
                    hull_list.push(list2[0]);
                }
                list1.reverse();
                list1.pop();
                list1.reverse();
                // list1 = list1.slice(1);
                this.draw_close();
                // console.log(points.length);
                // console.log(non_hull.length);
            }
            // else if(this.curr_x === this.next_x &amp;&amp; Math.abs(this.curr_y - this.next_y) > 1) {

            // }
            else if (this.curr_y === this.next_y) {
                this.curr_x = this.next_x;
                this.curr_y = this.next_y;
                this.next_x = this.non_hull[this.index + 1].x;
                this.next_y = this.non_hull[this.index + 1].y;
                this.dx = Math.sign(this.next_x - this.curr_x);
                this.slope = Math.sign(this.next_y - this.curr_y);
                if (this.curr_x !== this.next_x) {
                    this.slope = (this.next_y - this.curr_y) / (this.next_x - this.curr_x);
                }
                if (this.dx !== 0) {
                    this.slope = this.slope * this.dx;
                }
                this.original_slope = this.slope;
                this.original_dx = this.dx;
                this.reduce_speed();
                this.flag = 0;
                if (this.curr_x === this.next_x) {
                    this.eqal_x = 1;
                }
                else {
                    this.eqal_x = 0;
                }
                this.orientation = Math.atan(this.slope);
                if (this.curr_x === this.next_x) {
                    this.orientation = Math.sign(this.next_y - this.curr_y) * Math.PI / 2;
                }
                this.count = 0;
                this.index++;
                // points = points.slice(1);
                this.draw_close();
            }
            else if (this.flag === 0) {
                this.draw_close();
                if (this.count === 15) {
                    this.flag = 1;
                    this.count = 0;
                }
            }
            else {
                this.draw_open();
                if (this.count === 15) {
                    this.flag = 0;
                    this.count = 0;
                }
            }
            if (list1.length > 1 &amp;&amp; this.curr_y === list1[0].y) {
                if (f === true) {
                    hull_list.push(list2[0]);
                }
                list1.reverse();
                list1.pop();
                list1.reverse();
                // list1 = list1.slice(1);
                // console.log(points.length);
                // console.log(non_hull.length);
            }
        }
    }

}

/**
 * The Ghost function defines a JavaScript object representing a ghost character that moves between
 * specified points on a canvas while reducing its speed and updating its position accordingly.
 * @param x - The `x` parameter in the `Ghost` function represents the initial x-coordinate of the
 * ghost's position on the canvas. It determines where the ghost will be initially placed horizontally.
 * @param y - It seems like the description of the parameters is cut off. Could you please provide more
 * information about the parameters starting from "y:" so that I can assist you better?
 * @param next_x - It seems like your message got cut off after "next_x:". Could you please provide
 * more information on what you need help with regarding the "next_x" parameter in the Ghost function?
 * @param next_y - The `next_y` parameter in the `Ghost` function represents the y-coordinate of the
 * next position where the ghost will move to. It is used to determine the direction and speed at which
 * the ghost will move towards that position.
 * @param image - The `image` parameter in the `Ghost` function represents the image that will be used
 * to draw the ghost object on the canvas. It is the visual representation of the ghost character in
 * the game or application. This image could be a sprite, a PNG, a JPEG, or any other image format
 * @param size - The `size` parameter in the `Ghost` function represents the size of the ghost object.
 * It is used to determine the dimensions of the ghost when drawing it on the canvas. The `size`
 * parameter is used to calculate the position and dimensions of the ghost image within the canvas.
 * @returns The code provided defines a constructor function called `Ghost` that creates ghost objects
 * with specific properties and methods. The `Ghost` function takes in parameters for initial x and y
 * coordinates, next x and y coordinates, an image, and size.
 */
function Ghost(x, y, next_x, next_y, image, size) {
    this.x = x;
    this.y = y;
    this.initial_x = x;
    this.initial_y = y;
    this.size = size;
    this.next_x = next_x;
    this.next_y = next_y;
    this.image = image;
    this.dx = Math.sign(this.next_x - this.initial_x);
    this.slope = Math.sign(this.next_y - this.initial_y);
    if (this.initial_x !== this.next_x) {
        this.slope = (this.next_y - this.initial_y) / (this.next_x - this.initial_x);
    }
    this.reduce_speed = function () {
        while (this.dx >= 0.0001 &amp;&amp; (this.slope >= 2 || this.slope &lt;= -2)) {
            this.dx = this.dx / 2;
            this.slope = this.slope / 2;
        }
    }
    this.reduce_speed();
    this.get_position = function () {
        return { x: this.x, y: this.y };
    }
    // console.log(this.slope);
    // this.slope = this.slope / 10;
    this.draw = function () {
        // ctx.beginPath();
        // ctx.arc(this.initial_x, this.initial_y, 5, 0, 2 * Math.PI);
        // ctx.arc(this.next_x, this.next_y, 5, 0, 2 * Math.PI);
        // ctx.fillStyle = 'violet';
        // ctx.fill();
        // ctx.closePath();
        ctx.drawImage(this.image, this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
    }
    this.update = function () {
        if (this.initial_x !== this.next_x) {
            if (this.initial_x &lt; this.next_x) {
                if (this.x >= this.next_x) {
                    this.dx = -this.dx;
                    this.x = this.next_x;
                    this.y = this.next_y;
                }
                else if (this.x &lt;= this.initial_x) {
                    this.dx = -this.dx;
                    this.x = this.initial_x;
                    this.y = this.initial_y;
                }
            }
            else {
                if (this.x &lt;= this.next_x) {
                    this.dx = -this.dx;
                    this.x = this.next_x;
                    this.y = this.next_y;
                }
                else if (this.x >= this.initial_x) {
                    this.dx = -this.dx;
                    this.x = this.initial_x;
                    this.y = this.initial_y;
                }
            }
            if (this.initial_y &lt; this.next_y) {
                if (this.y >= this.next_y) {
                    this.slope = -this.slope;
                    this.y = this.next_y;
                }
                else if (this.y &lt;= this.initial_y) {
                    this.slope = -this.slope;
                    this.y = this.initial_y;
                }
            }
            else {
                if (this.y &lt; this.next_y) {
                    this.slope = -this.slope;
                    this.y = this.next_y;
                }
                else if (this.y > this.initial_y) {
                    this.slope = -this.slope;
                    this.y = this.initial_y;
                }
            }
        }
        else {
            // if points have same x coordinate
            if (this.initial_y &lt; this.next_y) {
                if (this.y >= this.next_y) {
                    this.slope = -this.slope;
                    this.y = this.next_y;
                }
                else if (this.y &lt;= this.initial_y) {
                    this.slope = -this.slope;
                    this.y = this.initial_y;
                }
            }
            else {
                if (this.y &lt; this.next_y) {
                    this.slope = -this.slope;
                    this.y = this.next_y;
                }
                else if (this.y > this.initial_y) {
                    this.slope = -this.slope;
                    this.y = this.initial_y;
                }
            }
        }
        // if(this.y > this.next_y || this.y &lt; this.initial_y) {
        //     this.slope = -this.slope;
        // }
        this.x += this.dx;
        this.y += this.slope;
        // console.log(this.slope);
        // console.log(this.x, this.y);
        this.draw();
    }

}

/**
 * The `draw` function in JavaScript updates the game canvas by clearing it, drawing elements such as
 * circles in different colors, updating ghost positions, and handling game logic based on the
 * positions of game elements.
 * @returns In the provided code snippet, the `draw` function is returning nothing explicitly. The
 * function contains conditional statements and loops to draw shapes on a canvas based on the data in
 * `list1`, `list2`, and `ghostList`. The function also updates the positions of objects like `pacman`
 * and `ghostList`. At the end of the function, there are conditional checks and a `return
 */
function draw() {
    // cc++;
    // // // console.log("in draw: ");
    // if(cc % 100 === 0) {
    //     console.log("in draw: ",cc);
    // }
    // if(flag2 === true) {
        req1 = requestAnimationFrame(draw);
    // }
    // else{
    //     return;
    // }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // for(var i = 0; i &lt; list2.length; i++) {
    if(ghostList.length - list2.length >= 1) {
        // ghostList.reverse();
        // ghostList.pop();
        // ghostList.reverse();
        ghostList.shift();
    }
    if(ghostList.length !== 0 &amp;&amp; f === true) {
        var ghost_pos = ghostList[0].get_position();
        var pacman_pos = pacman.get_position();
        if(Math.abs(ghost_pos.x - pacman_pos.x) &lt; 2 &amp;&amp; Math.abs(ghost_pos.y - pacman_pos.y) &lt; 2) {
            ghostList.reverse();
            ghostList.pop();
            ghostList.reverse();
        }
    }
    // }
    for(var itr = 0; itr &lt; list2.length; itr++) {
        ctx.beginPath();
        ctx.arc(list2[itr].x, list2[itr].y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
    }
    // console.log("in draw", list1.length);
    for(var i = 0; i &lt; list1.length; i++) {
        ctx.beginPath();
        ctx.arc(list1[i].x, list1[i].y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'yellow';
        ctx.fill();
    }
    // console.log("ghostList", ghostList);
    for(var i = 0; i &lt; ghostList.length; i++) {
        ghostList[i].update();
        // console.log(i);
    }
    if(list1.length > 0) {
        pacman.update();
        // console.log("in draw update call", list1.length);
    }
    else if(list2.length === 0) {
        if(ghostList.length > 0) {
            ghostList.shift();
        }
        pacman.draw_hull();
        console.log("FINISH draw hull call");
        cancelAnimationFrame(req1);
        // flag2 = false;
        return;
    }
    else {
        f = true;
        list1 = list2;
        hull_list.push(list2[0]);
        pacman.image_open = p_open;
        pacman.image_close = p_close;
        for(var i = 0; i &lt; ghostList.length; i++) {
            ghostList[i].image = afraid_g;
        }
        pacman.set_non_hull(list1);
    }
}

/**
 * The function `draw_in_next` in JavaScript draws convex hull points, pairs, and noncandidates with
 * different colors and handles the animation of ghost objects based on certain conditions.
 */
function draw_in_next(){
    // if(flag3 === true) {
    req2 = requestAnimationFrame(draw_in_next);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // }
    // else{
        // return;
    // }
    var index = idx;
    var pts = myConvexHull[index].points;
    const pairs = myConvexHull[index].pairs;
    const state = myConvexHull[index].state;
    const slope = myConvexHull[index].slope;
    const noncandidates = myConvexHull[index].noncandidates;
    // display pairs
    if(pairs !== null &amp;&amp; pairs.length !== 1)
    {
        ctx.beginPath();
        ctx.moveTo(pairs[0].x, pairs[0].y);
        ctx.lineTo(pairs[1].x, pairs[1].y);
        for (let i = 1; i &lt; pairs.length - 1; i++) {
            ctx.moveTo(pairs[i].x, pairs[i].y);
            ctx.lineTo(pairs[i+1].x, pairs[i+1].y);
        }
        ctx.closePath();
        ctx.strokeStyle = 'red';
        ctx.stroke();
    }

    if(state === 'leftmost_point')
    {
        ctx.save();
        // ctx.beginPath();
        ctx.fillStyle = 'yellow';
        ctx.arc(noncandidates.x, noncandidates.y, 5, 0, 2 * Math.PI);
        ctx.fill();
        // ctx.closePath();
        ctx.restore();
    }
    // else if(state !== 'upper_bridge' &amp;&amp;  state !== 'upper_hull' &amp;&amp; state !== 'lower_bridge' &amp;&amp; state !== 'lower_hull' &amp;&amp; state !== 'hull' &amp;&amp; pairs !== null)
    // {
    //     // draw pairs list
    //     // console.log("These are my pairs", pairs);
    //     ctx.beginPath();
    //     ctx.moveTo(pairs[0][0].x, pairs[0][0].y);
    //     ctx.lineTo(pairs[0][1].x, pairs[0][1].y);
    //     for (let i = 1; i &lt; pairs.length; i++) {
    //         ctx.moveTo(pairs[i][0].x, pairs[i][0].y);
    //         ctx.lineTo(pairs[i][1].x, pairs[i][1].y);
    //     }
    //     ctx.closePath();
    //     ctx.strokeStyle = 'green';
    //     ctx.stroke();
    // }
    // else if(state === 'upper_bridge' || state === 'upper_hull' || state === 'lower_bridge' || state === 'lower_hull' || state === 'hull')
    // {
    //     if(pairs !== null)
    //     {
    //         ctx.beginPath();
    //         ctx.moveTo(pairs[0].x, pairs[0].y);
    //         ctx.lineTo(pairs[1].x, pairs[1].y);
    //         for (let i = 1; i &lt; pairs.length - 1; i++) {
    //             ctx.moveTo(pairs[i].x, pairs[i].y);
    //             ctx.lineTo(pairs[i+1].x, pairs[i+1].y);
    //         }
    //         ctx.closePath();
    //         ctx.strokeStyle = 'blue';
    //         ctx.stroke();
    //     }
    // }
    
    if(state === 'hull')
    {
        // if(flag3 === true) {
            // requestAnimationFrame(draw);
        // }
        // else{
        //     return;
        // }
        if(pairs.length === 2 &amp;&amp; flag3 === true)
        {
            // list3.push([pairs[0], pairs[1]]);
            // var dxs = [];
            // var slopes = [];
            // if(indexOfGhosts.findIndex(index) === -1) {
            //     console.log("JJJJJ");
            //     indexOfGhosts.push(index);
            // }

            // this is to avoid same index to be added again
            var found = false;
            for(var i = 0; i &lt; indexOfGhosts.length; i++) {
                if(indexOfGhosts[i] === index) {
                    found = true;
                    break;
                }
            }
            if(found === false) {
                indexOfGhosts.push(index);
            }
            
            // this is to avoid the same ghost to be added again
            for(var i = 0; i &lt; ghostList_in_next.length; i++) {
                if(pairs[0].x === ghostList_in_next[i].initial_x &amp;&amp; pairs[0].y === ghostList_in_next[i].initial_y &amp;&amp; pairs[1].x === ghostList_in_next[i].next_x &amp;&amp; pairs[1].y === ghostList_in_next[i].next_y) {
                    ghostList_in_next.splice(i, 1);
                    break;
                }
            }
            ghostList_in_next.push(new Ghost(pairs[0].x, pairs[0].y, pairs[1].x, pairs[1].y, cyan_g, 20));
            // for(var i = 0; i &lt; ghostList_in_next.length - 1; i++) {
            //     ghostList_in_next[i].dx = dxs[i];
            //     ghostList_in_next[i].slope = slopes[i];
            // }
            flag3 = false;
        }
        
    }

    // display points

    // if(noncandidates !== null &amp;&amp; noncandidates.length === 3)
    // {
    //     // console.log("noncandidates", noncandidates);
    //     // console.log("pts", pts);
    //     for(let itr = 0; itr &lt; noncandidates.length; itr++)
    //     {
    //         for(let j = 0; j &lt; pts.length; j++)
    //         {
    //             if(noncandidates[itr].x === pts[j].x &amp;&amp; noncandidates[itr].y === pts[j].y)
    //             {
    //                 pts.splice(j, 1);
    //                 break;
    //             }
    //         }
    //     }
    //     // console.log("pts", pts);
    // }


    if (pts !== null) {
        pts.forEach(point => {
            if(((state === 'leftmost_point' || state === 'orientation_counter_clock' || state === 'orientation_clock') &amp;&amp; (point.x === noncandidates.x &amp;&amp; point.y === noncandidates.y)))
            {

            }
            else
            {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'black';
                ctx.fill();
                ctx.closePath();
            }
        });
    }

    // if (noncandidates !== null &amp;&amp; noncandidates.length === 3) {
    //     noncandidates.forEach(point => {
    //         ctx.beginPath();
    //         ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
    //         ctx.fillStyle = 'yellow';
    //         ctx.fill();
    //         ctx.closePath();
    //     });
    // }

    if (noncandidates !== null &amp;&amp; noncandidates.length === 3) {
        // Draw points
        noncandidates.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();
            ctx.closePath();
        });
    
        // Draw lines
        ctx.beginPath();
        ctx.moveTo(noncandidates[0].x, noncandidates[0].y); 
        ctx.lineTo(noncandidates[2].x, noncandidates[2].y); 
        ctx.lineTo(noncandidates[1].x, noncandidates[1].y);
        ctx.strokeStyle = 'blue'; 
        ctx.stroke(); 
        ctx.closePath();
    }
    



    if (noncandidates !== null &amp;&amp; noncandidates.length === 1) {
            ctx.beginPath();
            ctx.arc(noncandidates.x, noncandidates.y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();
            ctx.closePath();
    }


    if(state === 'hull')
    {
        // make lines of points
        console.log("hull ... ");

        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(var i = 0; i &lt; pts.length - 1; i++)
        {
            ctx.lineTo(pts[i+1].x, pts[i+1].y);
        }
        ctx.lineTo(pts[0].x, pts[0].y);
        ctx.closePath();
        ctx.stroke();
        cancelAnimationFrame(req2);
        
        // done fore previous button
        hull_list = [];

        var hull = pts.slice();
        list1 = [];
        list2 = hull.slice();
        list2.push(hull[0]);
        for (var itr = 0; itr &lt; list2.length - 1; itr++) {
            // console.log(points[i].x, points[i].y);
            ghostList.push(new Ghost(list2[itr].x, list2[itr].y, list2[itr + 1].x, list2[itr + 1].y, cyan_g, 20));
        }
        if(list1.length > 0) {
            pacman = new Pacman(list1, p_open, p_close, 25);
        }else{
            pacman = new Pacman(list2, p_open, p_close, 25);
        }
        req1 = requestAnimationFrame(draw);
    }
    if(indexOfGhosts.length > 0 &amp;&amp; ghostList_in_next.length > 0 &amp;&amp; indexOfGhosts[indexOfGhosts.length - 1] > index &amp;&amp; flag2 === true) {
        console.log("index &amp; indexOfGhosts[indexOfGhosts.length - 1]", index, indexOfGhosts[indexOfGhosts.length - 1])
        console.log(indexOfGhosts);
        indexOfGhosts.pop();
        ghostList_in_next.pop();
        flag2 = false;
    }
    // console.log("index &amp; ghostList_in_next.length", index, ghostList_in_next.length);
    for(var i = 0; i &lt; ghostList_in_next.length; i++) {
        ctx.beginPath();
        ctx.arc(ghostList_in_next[i].initial_x, ghostList_in_next[i].initial_y, 5, 0, 2 * Math.PI);
        ctx.arc(ghostList_in_next[i].next_x, ghostList_in_next[i].next_y, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'violet';
        ctx.fill();
        ctx.closePath();
        ghostList_in_next[i].update();
    }
}



// ConvexHull.js
/* The class ConvexHull implements an algorithm to find the convex hull of a set of points using Jarvis
March method. */
/* The ConvexHull class in JavaScript implements the Jarvis March algorithm to find the convex hull of
a set of points. */
class ConvexHull {
    constructor(points) {
        this.points = points;
    }

    findConvexHull() {
        if (this.points.length &lt;= 1) return this.points;

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        const orientation = (p, q, r) => {
            let val = (q.y - p.y) * (r.x - q.x) -
            (q.x - p.x) * (r.y - q.y);
            
            if (val === 0) {
                return 0;
            }
            return (val > 0) ? 1 : 2;
        }
        
        const findHull = (points) => {

            console.log("I am in Jarvis march");
            shuffle(points);
            console.log(points);
            myConvexHull.push({state: outputindex++, points: points, pairs: null, slope: null, state: 'initial_points', noncandidates: null});
            textBoxEle.push("Initial points are : ");
            let hull = [];
            let n = points.length;

            let left = 0;
            for (let i = 1; i &lt; n; i++) {
                if (points[i].x &lt; points[left].x) {
                    left = i;
                }
            }
            myConvexHull.push({state: outputindex++, points: points, pairs: null, slope: null, state: 'leftmost_point', noncandidates: points[left]});
            textBoxEle.push("Computing the leftmost point")

            let p = left, q;
            do {
                hull.push(points[p]);
                q = (p + 1) % n;

                for (let i = 0; i &lt; n; i++) {
                    // console.log("p, i, q", points[p], points[i], points[q]);
                    if (orientation(points[p], points[i], points[q]) === 2)
                    {
                        q = i;
                        myConvexHull.push({state: outputindex++, points: points, pairs: hull.slice(), slope: null, state: 'orientation_counter_clock', noncandidates: [points[p], points[i], points[q]]});
                        textBoxEle.push("Current smallest polar angle relative to the current point on the hull")
                    }
                    else
                    {
                        myConvexHull.push({state: outputindex++, points: points, pairs: hull.slice(), slope: null, state: 'orientation_clock', noncandidates: [points[p], points[i], points[q]]});
                        textBoxEle.push("For each point computing the polar angle with the current point on the hull")

                    }
                }
                p = q;

            } while (p !== left);
            console.log(hull);
            myConvexHull.push({state: outputindex++, points: hull, pairs: hull, slope: null, state: 'hull', noncandidates: null});
            textBoxEle.push("Final Hull Computed")
            console.log("no of states : ", myConvexHull.length);
            return hull;
        }


        const hull = findHull(this.points);
        return hull;
    }
}

/**
 * The Canvas component in JavaScript allows users to interact with a canvas element, draw points,
 * create a convex hull, navigate through steps, and add points using x, y coordinates.
 * @returns The `Canvas` component is being returned. It contains a canvas element for drawing points
 * and convex hulls, along with buttons for navigation and interaction. The component also includes
 * input fields for adding points and a textarea for displaying steps. The component handles mouse
 * events, keyboard events, and animations for displaying the convex hull algorithm steps.
 */
const Canvas = () => {
    const canvasRef = useRef(null);
    const [finished, setFinished] = useState(false);
    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
    const [textBoxValue, setTextBoxValue] = useState('');
    const [pointsInput, setPointsInput] = useState('');
    var [points, setPoints] = useState([]);
    var [val, setVal] = useState(0);
    const keysPressed = useRef({});
    const [hoverCoordinates, setHoverCoordinates] = useState({ x: 0, y: 0 });
    const inputRef = useRef(null);

    // useEffect(() => {
    //     const handleKeyInput = (event) => {
    //         keysPressed.current[event.key] = true;
    
    //         if (keysPressed.current['u'] &amp;&amp; keysPressed.current['b']) {
    //             for(let i = val; i &lt; val.length - 1; i++) {  
    //                 if(myConvexHull[val].state === 'upper_bridge') {
    //                     break;
    //                 }
    //                 else
    //                 {
    //                     handleNext();
    //                 }
    //         }
    //     }
    
    //         if(keysPressed.current['l'] &amp;&amp; keysPressed.current['b']) {
    //             for(let i = val; i &lt; val.length - 1; i++) {
    //                 if(myConvexHull[val].state === 'lower_bridge') {
    //                     break;
    //                 }
    //                 else
    //                 {
    //                     handleNext();
    //                 }
    //             }
    //         }
    
    //         if(keysPressed.current['u'] &amp;&amp; keysPressed.current['h']) {
    //             for(let i = val; i &lt; val.length - 1; i++) {
    //                 if(myConvexHull[val].state === 'upper_hull') {
    //                     break;
    //                 }
    //                 else
    //                 {
    //                     handleNext();
    //                 }
    //             }
    //         }
    
    //         if(keysPressed.current['l'] &amp;&amp; keysPressed.current['h']) {
    //             for(let i = val; i &lt; val.length - 1; i++) {
    //                 if(myConvexHull[val].state === 'lower_hull') {
    //                     break;
    //                 }
    //                 else
    //                 {
    //                     handleNext();
    //                 }
    //             }
    //         }
    
    //         if(keysPressed.current['h'])
    //         {
    //             for(let i = val; i &lt; val.length - 1; i++) {
    //                 if(myConvexHull[val].state === 'hull') {
    //                     break;
    //                 }
    //                 else
    //                 {
    //                     handleNext();
    //                 }
    //             }
    //         }
    
    //         if(keysPressed.current['ArrowRight']) {
    //             handleNext();
    //         }
    
    //         if(keysPressed.current['ArrowLeft']) {
    //             handlePrev();
    //         }
    
    //     };
    
    //     window.addEventListener('keydown', handleKeyInput);
    
    //     return () => {
    //         window.removeEventListener('keydown', handleKeyInput);
    //     };
    // }, []);

    useEffect(() => {
        canvas = canvasRef.current;
        ctx = canvas.getContext('2d');

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw convex hull
        if (finished) {
            const convexHull = new ConvexHull(points).findConvexHull();
            console.log(myConvexHull);
            points = convexHull;
            ctx.beginPath();
            ctx.moveTo(convexHull[0].x, convexHull[0].y);
            for (let i = 1; i &lt; convexHull.length; i++) {
                ctx.lineTo(convexHull[i].x, convexHull[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'red';
            ctx.stroke();
        }

        // Draw points
        points.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();
        });

    }, [points, finished]);

    useEffect(() => {
        const handleMouseMove = (event) => {
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            setMousePos({ x, y });
        };

        const canvas = canvasRef.current;
        canvas.style.cursor = 'pointer';        
        canvas.addEventListener('mousemove', handleMouseMove);

        return () => {
            canvas.removeEventListener('mousemove', handleMouseMove);
        };
    }, []);

    const handleAddPoint = () => {
        var [x, y] = pointsInput.split(',').map(coord => parseFloat(coord.trim()));

        [x, y] = [Math.floor(x), Math.floor(y)];

        if (!isNaN(x) &amp;&amp; !isNaN(y) &amp;&amp; x >= 0 &amp;&amp; x &lt;= canvas.width &amp;&amp; y >= 0 &amp;&amp; y &lt;= canvas.height) {
            setPoints([...points, { x, y }]);
            setPointsInput('');
            inputRef.current.focus();
            let audio = new Audio(point_added);
            audio.currentTime = 0.2;
            audio.play();
        } else {
            alert('Invalid input. Please enter valid coordinates in the format "x, y".');
        }
    };

    const handleCanvasClick = (event) => {
        if (!finished) {
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var y = event.clientY - rect.top;
            x = Math.floor(x);
            y = Math.floor(y);
            setPoints(prevPoints => [...prevPoints, { x, y }]);
            let audio = new Audio(point_added);
            audio.currentTime = 0.2;
            audio.play();
        }
    };

    const handleFinishClick = async () => {
        setFinished(true);
        // while(true){
        //     await delay(1500);
        //     let audio = new Audio(siren);
        //     audio.play();
        // }
    };

    const delay = (ms) => {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const handleSkip = async () => {
        let temp = val;
        for (let itr = temp; itr &lt; myConvexHull.length - 1; itr++) {
            handleNext();
            val++;
            await delay(500); // Wait for 0.5 seconds
        }
        if (val === myConvexHull.length - 1) {
            await delay(8000);
        }
    }
    const handlePointsInputChange = (e) => {
        setPointsInput(e.target.value);
      };

    const clearCanvas = () => {
        setPoints([]);
        let audio = new Audio(pacmna_death);
        audio.play();
        setFinished(false);
    };

    const handleNext = () => {
        console.log("val", val);
        var index = val &lt; myConvexHull.length - 1 ? val + 1 : val;
        // val++;
        setVal(index);
        console.log("val", val);
        console.log(index);
        console.log(myConvexHull[index]);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        
        // Draw convex hull
        if (finished) {
            // requestAnimationFrame(draw);
            let audio = new Audio(state_change);
            audio.play();

            if (req2 != null) {
                cancelAnimationFrame(req2);
            }
            // flag4 = true;
            flag3 = true;
            idx = index;
            setTextBoxValue(textBoxEle[index]);
            req2 = requestAnimationFrame(draw_in_next);
        }
    };

    

    const handlePrev = () => {
        var index = val > 0 ? val - 1 : 0;
        setVal(index);
        console.log(index);
        console.log(myConvexHull[index]);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw convex hull

        if (finished) {
            let audio = new Audio(state_change);
            audio.play();
            if (req2 != null) {
                cancelAnimationFrame(req2);
            }
            flag3 = true;
            flag2 = true;
            idx = index;
            setTextBoxValue(textBoxEle[index]);
            req2 = requestAnimationFrame(draw_in_next);
        }
    };


    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.key === 'q') {
                const newPoints = [];
                while (newPoints.length &lt; 5) {
                    const x_in = Math.floor(Math.random() * (canvasRef.current.width));
                    const y_in = Math.floor(Math.random() * (canvasRef.current.height));
                    let x = Math.floor(x_in);
                    let y = Math.floor(y_in);
                    // let x = x_in + 0.6666641235352;
                    // let y = y_in + 0.7708435058594;
                    if (!newPoints.some(point => point.x === x &amp;&amp; point.y === y)) {
                        newPoints.push({ x, y });
                    }
                }
                setPoints(prevPoints => [...prevPoints, ...newPoints]);
            }
            if(finished) {
                if(event.key === 'ArrowRight') {

                    handleNext();
                }
                else if(event.key === 'ArrowLeft') {
                    handlePrev();
                }
                else if(event.key === 'b') {
                    let itr = val;
                    for(let i = itr; i &lt; myConvexHull.length; i++) {
                        handleNext();
                        val++;
                        if(myConvexHull[val].state === 'lower_bridge' || myConvexHull[val].state === 'upper_bridge' || myConvexHull[val].state === 'lower_hull' || myConvexHull[val].state === 'upper_hull' || myConvexHull[val].state === 'hull') {
                            break;
                        }
                    }
                }
                else if(event.key === 'u') {
                    let itr = val;
                    for(let i = itr; i &lt; myConvexHull.length; i++) {
                        if(myConvexHull[val].state === 'upper_hull') {
                            break;
                        }
                        handleNext();
                        val++;
                    }
                }
                else if(event.key === 'l') {
                    let itr = val;
                    for(let i = itr; i &lt; myConvexHull.length; i++) {
                        if(myConvexHull[val].state === 'lower_hull') {
                            break;
                        }
                        handleNext();
                        val++;
                    }
                }
                else if(event.key === 'h') {
                    let itr = val;
                    for(let i = itr; i &lt; myConvexHull.length; i++) {
                        handleNext();
                        val++;
                    }
                }
            }
        };

        window.addEventListener('keydown', handleKeyDown);

        return () => {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [handleNext, handlePrev, finished, val]);


    return (
        &lt;div>

    
            &lt;h4> Jarvis March algorithm&lt;/h4>
            &lt;canvas className='canvascss'
                ref={canvasRef}
                width={1300}
                height={550}
                onClick={handleCanvasClick}
                style={{ cursor: 'crosshair' }}
            />
            &lt;br />
            &lt;button className='btns buttons' onClick={handlePrev}> Prev &lt;/button>
            &lt;button className="buttons" onClick={handleFinishClick} disabled={points.length === 0 || finished}>
                Finish
            &lt;/button>
            &lt;button className="buttons" onClick={clearCanvas} disabled={finished}>
                Clear
            &lt;/button>

            &lt;button className='btns buttons' onClick={handleNext}> Next &lt;/button>

            &lt;button className='buttons' onClick={handleSkip}> End &lt;/button>
            &lt;div className='input-container'>
            &lt;input
                ref={inputRef}
                type="text"
                placeholder="Enter x, y coordinates"
                value={pointsInput}
                onChange={handlePointsInputChange}
                className="centered-input" // Add a class for styling
            />
            &lt;button className = 'buttons add_point' onClick={handleAddPoint}>Add Point&lt;/button>
            &lt;/div>
                &lt;div className="textbox-container">
                &lt;textarea
                readOnly
                className="custom-textbox"
                value={textBoxValue} 
                placeholder="Steps will appear here"
                rows={4}
                cols={50}
                />
                &lt;/div>
            

        &lt;/div>
        
    );
};


/* The above code is a JavaScript export statement exporting a class or object named Canvas. */
export default Canvas;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Canvasvar.html">Canvasvar</a></li><li><a href="Ghost_complete.html">Ghost_complete</a></li><li><a href="Pacman_complete.html">Pacman_complete</a></li><li><a href="findConvexHull.html">findConvexHull</a></li></ul><h3>Classes</h3><ul><li><a href="ConvexHull.html">ConvexHull</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Canvas">Canvas</a></li><li><a href="global.html#Ghost">Ghost</a></li><li><a href="global.html#Pacman">Pacman</a></li><li><a href="global.html#colorList">colorList</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#draw_in_next">draw_in_next</a></li><li><a href="global.html#findHull">findHull</a></li><li><a href="global.html#findMedian">findMedian</a></li><li><a href="global.html#get_T">get_T</a></li><li><a href="global.html#get_lower_bridge">get_lower_bridge</a></li><li><a href="global.html#get_lower_hull">get_lower_hull</a></li><li><a href="global.html#get_upper_bridge">get_upper_bridge</a></li><li><a href="global.html#get_upper_hull">get_upper_hull</a></li><li><a href="global.html#kthSmallest">kthSmallest</a></li><li><a href="global.html#partition">partition</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Apr 02 2024 20:55:03 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
