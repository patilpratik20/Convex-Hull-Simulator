<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: document.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: document.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * The `removeDuplicates` function takes an array of objects and removes any duplicate objects based on
 * their `x` and `y` properties.
 * @param arr - It looks like the code you provided is a function called `removeDuplicates` that takes
 * an array `arr` as a parameter. The function iterates over the array and removes any duplicate
 * elements based on the `x` and `y` properties of the objects in the array.
 */
function removeDuplicates (arr)  {
    for (var i = 0; i &lt; arr.length; i++) {
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[i].x === arr[j].x &amp;&amp; arr[i].y === arr[j].y) {
                // arr.splice(j, 1);
                j--;
            }
        }
    }
}

// Helper function to find the convex hull of a set of points
/**
* The `findHull` function in JavaScript computes the convex hull of a set of points using a divide and
* conquer algorithm.
* @param points - The `findHull` function you provided seems to be implementing the Convex Hull
* algorithm. The algorithm computes the convex hull of a set of points using the Divide and Conquer
* approach.
* @returns The function `findHull` is returning the final convex hull of the input points after
* performing the necessary computations and merging the upper and lower hulls.
*/

function findHull()  {

    console.log("I am in KPS");
    let pmin_u, pmin_l, pmax_u, pmax_l;

    pmin_l = pmin_u = pmax_l = pmax_u = points[0];
    for (let i = 1; i &lt; points.length; i++) {
        let curr_point = points[i];
        if (points[i].x &lt; pmin_l.x) {
            pmin_l = points[i];
            pmin_u = points[i];
        }
        else if (points[i].x > pmax_l.x) {
            pmax_l = points[i];
            pmax_u = points[i];
        }
        else if (points[i].x === pmin_l.x) {
            if (points[i].y > pmin_u.y)
                pmin_u = points[i];
            else if (points[i].y &lt; pmin_l.y)
                pmin_l = points[i];
        }
        else if (points[i].x === pmax_l.x) {
            if (points[i].y > pmax_u.y)
                pmax_u = points[i];
            else if (points[i].y &lt; pmax_l.y)
                pmax_l = points[i];
        }
    } // point initialization
    console.log("pmin_u", pmin_u);
    console.log("pmax_u", pmax_u);
    // ctx.strokeStyle = 'blue'; // Set the color to red
    // ctx.setLineDash([5, 15]); // Set the line dash to a pattern of 5 pixels dash, 15 pixels gap
    // ctx.moveTo(pmin_u.x, pmin_u.y);
    // ctx.lineTo(pmax_u.x, pmax_u.y);
    // ctx.stroke();
    // ctx.setLineDash([]); // Set the line dash to solid

    // ctx.clearRect(0, 0, canvas.width, canvas.height);
    myConvexHull.push({ state: outputindex++, points: points, pairs: null, slope: null, state: 'initial_points', noncandidates: null });
    textBoxEle.push("This algorithm functions by separately computing the upper and lower hulls of our points. To obtain the complete convex hull, we can simply merge the upper and lower hulls")
    myConvexHull.push({ state: outputindex++, points: points, pairs: [pmin_u, pmax_u], slope: null, state: 'pmiu_pmaxu', noncandidates: null });
    textBoxEle.push(" Presently, let's concentrate on the lower portion of our points, specifically those positioned below the segment delineated by x_min and x_max.")
    let lower_T = get_T(pmin_u, pmax_u, points, false);

    let noncandidates = points.filter(pt => !lower_T.includes(pt));

    myConvexHull.push({ state: outputindex++, points: lower_T, pairs: null, slope: null, state: 'lower_T', noncandidates: noncandidates });
    textBoxEle.push('Now that we have the lower points we begin the computation of lower hull.This is a divide and conquer algorithm so we will divide our points into two sets based on median x value')
    let lower_hull = get_lower_hull(pmin_u, pmax_u, lower_T);
    // console.log("final upper_hull", upper_hull);
    removeDuplicates(lower_hull);
    ////// Sort in increasing order of x

    lower_hull.sort((a, b) => {
        if (a.x &lt; b.x) return -1;
        else if (a.x > b.x) return 1;
    });


    // console.log("final upper_hull", upper_hull);

    let upper_T = get_T(pmin_l, pmax_l, points, true);
    let upper_hull = get_upper_hull(pmin_l, pmax_l, upper_T);
    // console.log("final lower_hull", lower_hull);
    removeDuplicates(upper_hull);

    upper_hull.sort((a, b) => {
        if (a.x > b.x) return -1;
        else if (a.x &lt; b.x) return 1;
    });
    ////// Sort in decreasing order of x
    // console.log("final lower_hull", lower_hull);

    let hull_edges = [];
    hull_edges = hull_edges.concat(upper_hull);
    hull_edges = hull_edges.concat(lower_hull);

    // console.log("hull_edges", hull_edges);
    removeDuplicates(hull_edges);
    // console.log("hull_edges", hull_edges);

    if (pmin_u.x !== pmin_l.x || pmin_u.y !== pmin_l.y) {
        hull_edges.push(pmin_l);
        hull_edges.push(pmin_u);
    }
    if (pmax_l.x !== pmax_u.x || pmax_l.y !== pmax_u.y) {
        hull_edges.push(pmax_l);
        hull_edges.push(pmax_u);
    }
    // hull_edges.sort((a, b) => {
    //     if (a.x &lt; b.x) return -1;
    //     else if (a.x > b.x) return 1;
    //     else return a.y &lt; b.y ? -1 : 1;
    // });
    let hull = [];
    // console.log("hull_edges", hull_edges);
    hull.push(hull_edges[0]);
    let i = 1;
    while (i &lt; hull_edges.length) {
        // while (i &lt; hull_edges.length &amp;&amp; (hull_edges[i].x === hull_edges[i - 1].x &amp;&amp; hull_edges[i].y === hull_edges[i - 1].y))
        //     i++;

        if (i &lt; hull_edges.length)
            hull.push(hull_edges[i]);

        i++;
    }
    // flag = true;
    console.log("points", points);
    console.log("hull", hull);
    noncandidates = [];

    for (let i = 0; i &lt; points.length; i++) {
        let isCandidate = true;
        for (let j = 0; j &lt; hull.length; j++) {
            if (Math.abs(hull[j].x - points[i].x) &lt; 0.0001 &amp;&amp; Math.abs(hull[j].y - points[i].y) &lt; 0.0001) {
                isCandidate = false;
                break;
            }
        }
        if (isCandidate) {
            noncandidates.push(points[i]);
        }
    }
    console.log("non candidates ", noncandidates);
    myConvexHull.push({ state: outputindex++, points: hull, pairs: null, slope: null, state: 'hull', noncandidates: noncandidates });
    textBoxEle.push("Final Hull is displayed by merging lower and upper hull and displayed by black borders")
    // list1 = noncandidates.slice();
    // list2 = hull.slice();
    // list2.push(hull[0]);
    // for (var itr = 0; itr &lt; list2.length - 1; itr++) {
    //     // console.log(points[i].x, points[i].y);
    //     ghostList.push(new Ghost(list2[itr].x, list2[itr].y, list2[itr + 1].x, list2[itr + 1].y, cyan_g, 20));
    // }
    // if(list1.length > 0) {
    //     pacman = new Pacman(list1, p_open, p_close, 25);
    // }else{
    //     pacman = new Pacman(list2, p_open, p_close, 25);
    // }
    // req1 = requestAnimationFrame(draw);
    return hull;
};
/**
* The `findMedian` function takes an array of numbers, sorts it in ascending order, and returns the
* median value.
* @param arr - The `arr` parameter in the `findMedian` function is an array of numbers for which we
* want to find the median. The function sorts the array in ascending order and then calculates the
* median value.
* @returns The findMedian function is returning the median value of the input array after sorting it
* in ascending order.
*/

function findMedian (arr) {
    arr.sort((a, b) => a - b);
    return arr[Math.floor(arr.length / 2)];
}

/**
* The `partition` function takes an array, a left index, a right index, and a pivot value, and
* partitions the array such that elements less than or equal to the pivot are moved to the left side
* of the array.
* @param arr - The `arr` parameter in the `partition` function represents an array that you want to
* partition. It contains the elements that you want to rearrange based on a specific pivot element
* `x`.
* @param l - The parameter `l` in the `partition` function represents the starting index of the
* subarray within the array `arr` that you want to partition. It indicates the left boundary of the
* subarray.
* @param r - The parameter `r` in the `partition` function represents the index of the rightmost
* element in the array segment being partitioned. It is used to determine the range within which the
* partitioning operation should be performed.
* @param x - The `x` parameter in the `partition` function represents the pivot element around which
* the array `arr` will be partitioned. The function rearranges the elements in the array such that all
* elements less than or equal to `x` are placed before `x`, and all elements greater than `
* @returns The `partition` function is returning the index `i` where the element `x` is placed after
* partitioning the array `arr` within the range from index `l` to index `r`.
*/
function partition (arr, l, r, x) {
    let i;
    for (i = l; i &lt; r; i++)
        if (arr[i] === x)
            break;
    [arr[i], arr[r]] = [arr[r], arr[i]];

    i = l;
    for (let j = l; j &lt;= r - 1; j++) {
        if (arr[j] &lt;= x) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
        }
    }
    [arr[i], arr[r]] = [arr[r], arr[i]];
    return i;
}

/**
* The function `kthSmallest` finds the kth smallest element in an array using the median of medians
* algorithm.
* @param arr - The `arr` parameter in the `kthSmallest` function represents an array of elements from
* which you want to find the kth smallest element.
* @param l - The parameter `l` in the `kthSmallest` function represents the starting index of the
* subarray within the main array `arr` that we are considering. It indicates the left boundary of the
* subarray.
* @param r - The parameter `r` in the `kthSmallest` function represents the index of the last element
* in the array `arr`. It indicates the right boundary of the subarray being considered for finding
* the kth smallest element.
* @param k - The parameter `k` in the `kthSmallest` function represents the position of the element
* you want to find in the sorted array. For example, if `k` is 1, you are looking for the smallest
* element in the array. If `k` is 2, you
* @returns The function `kthSmallest` is returning the kth smallest element in the given array `arr`
* within the range specified by `l` and `r`. If the value of `k` is within the valid range (greater
* than 0 and less than or equal to the size of the subarray), the function performs a series of
* operations to find the kth smallest element using a
*/
function kthSmallest(arr, l, r, k)  {
    if (k > 0 &amp;&amp; k &lt;= r - l + 1) {
        let n = r - l + 1;
        let median = Array(Math.floor((n + 4) / 5)).fill(0); // this is a doubtable line
        let i;
        for (i = 0; i &lt; Math.floor(n / 5); i++)
            median[i] = findMedian(arr.slice(l + i * 5, l + i * 5 + 5));
        if (i * 5 &lt; n) {
            median[i] = findMedian(arr.slice(l + i * 5, l + i * 5 + n % 5));
            i++;
        }

        let medOfMed = (i === 1) ? median[i - 1] : kthSmallest(median, 0, i - 1, Math.floor(i / 2));

        let pos = partition(arr, l, r, medOfMed);

        if (pos - l === k - 1)
            return arr[pos];
        if (pos - l > k - 1)
            return kthSmallest(arr, l, pos - 1, k);

        return kthSmallest(arr, pos + 1, r, k - pos + l - 1);
    }

    return Number.MAX_SAFE_INTEGER; // don't be afraid, this is INT_MAX 
}
/**
* The function `get_T` calculates and returns a subset of points that lie between two given points
* based on a specified condition.
* @param p1 - It looks like you were about to provide some information about the parameters for the
* `get_T` function. Please go ahead and provide the details for the `p1` parameter so that I can
* assist you further.
* @param p2 - It seems like you were about to provide some information about the parameters, but you
* stopped after mentioning `p2`. How can I assist you further with this code snippet?
* @param points - It seems like you were about to provide some information about the `points`
* parameter but it got cut off. Could you please provide more details or let me know how I can assist
* you further with the `points` parameter in the `get_T` function?
* @param flag - The `flag` parameter in the `get_T` function is used to determine whether to include
* points with a slope greater than or less than the calculated slope in the `upper_T` array. If `flag`
* is `false`, only points with a slope greater than the calculated slope will be included
* @returns The function `get_T` is returning an array `upper_T` containing points that lie between
* points `p1` and `p2` based on the slope comparison with the flag condition. The array `upper_T` also
* includes points `p1` and `p2`.
*/

function get_T  (p1, p2, points, flag) {
    let upper_T = [];
    let slope = (p1.y - p2.y) / (p1.x - p2.x);

    for (let i = 0; i &lt; points.length; i++) {
        let curr_point = points[i];

        if (curr_point.x > p1.x &amp;&amp; curr_point.x &lt; p2.x) {
            let curr_slope = (p1.y - curr_point.y) / (p1.x - curr_point.x);

            if (!flag) {
                if (curr_slope > slope) upper_T.push(curr_point);
            } else {
                if (curr_slope &lt; slope) upper_T.push(curr_point);
            }
        }
    }

    upper_T.push(p1);
    upper_T.push(p2);
    // // // console.log("upper_T");
    // // // console.log(upper_T);
    return upper_T;
} // ye mara recursive calls mai points chatne ke liye kamm atta hai.

/**
* The function `get_lower_bridge` in JavaScript sorts points, calculates median slope, and recursively
* finds the lower bridge of a set of points based on the median.
* @param points - The `points` parameter in the `get_lower_bridge` function represents an array of
* points on a 2D plane. Each point is represented as an object with `x` and `y` coordinates. The
* function sorts these points based on their `x` values and then performs calculations to find
* @param median - The `get_lower_bridge` function you provided seems to be calculating the lower
* bridge of a set of points based on a given median value. However, it looks like the description of
* the `median` parameter is missing. Could you please provide more information about what the `median`
* parameter represents in this
* @returns The function `get_lower_bridge` is returning the lower bridge points based on the input
* points and median value. It recursively calls itself to find the lower hull points and eventually
* returns the lower bridge points.
*/
function get_lower_bridge (points, median)  {
    // // console.log("get upper bridge starts");
    points.sort((a, b) => a.x &lt; b.x ? -1 : 1);

    console.log("points upper bridge", points);
    if (points.length === 1) {
        return [points[0], points[0]];
    }
    // let candidates = new Array(points.length);
    // let pairs = new Array(Math.floor(points.length / 2) + 1);
    let candidates = [];
    let pairs = [];
    // // // console.log("points");
    // // // console.log(points);
    // // // console.log(points.length);
    if (points.length % 2 === 0) {
        for (let i = 0; i &lt; points.length; i += 2) {
            let first_pt = points[i];
            let second_pt = points[i];
            if (i + 1 !== points.length) {
                second_pt = points[i + 1];
            }
            let curr_pair = [first_pt, second_pt];
            pairs.push(curr_pair);
        }
    }
    else {
        candidates.push(points[0]);
        for (let i = 1; i &lt; points.length; i += 2) {
            let first_pt = points[i];
            let second_pt = points[i];
            if (i + 1 !== points.length) {
                second_pt = points[i + 1];
            }

            let curr_pair = [first_pt, second_pt];
            pairs.push(curr_pair);
        }
    }

    myConvexHull.push({ state: outputindex++, points: points, pairs: pairs, median_slope: null, state: 'pairs', noncandidates: null });
    textBoxEle.push("if we say your ideal edge has slope of k.we can try out different slopes and see this is they form bridge edge.let's start drawing random edges between our points")

    let slopes_len = pairs.length;
    let slopes = [];
    // // // console.log("pairs");
    // // // console.log(pairs.length);
    // // // console.log(pairs);
    for (let i = 0; i &lt; pairs.length; i++) {
        let p1 = pairs[i][0];
        let p2 = pairs[i][1];
        let x1 = p1.x;
        let x2 = p2.x;
        let y1 = p1.y;
        let y2 = p2.y;
        // // // console.log("p1", p1);
        // // // console.log("p2", p2);
        // // // console.log("x1", x1);
        // // // console.log("x2", x2);
        // // // console.log("y1", y1);
        // // // console.log("y2", y2);
        if (x1 === x2) {
            if (y1 > y2) {
                candidates.push(p1);
            }
            else {
                candidates.push(p2);
            }
            slopes[i] = Infinity;
        }
        else {
            let slope = (y2 - y1) / (x2 - x1);
            slopes[i] = slope;
        }
    }
    let arr = [];
    let len = 0;
    for (let i = 0; i &lt; slopes_len; i++) {
        if (slopes[i] !== Infinity) {
            arr[len++] = slopes[i];
        }
    } // array ke andar slopes daal diye
    // // console.log("hello upper bridge");
    // if(len === 0)
    // {
    //     return Infinity, Infinity;
    // } // check....

    let median_slope;
    if (len === 1)
        median_slope = arr[0];
    else
        median_slope = kthSmallest(arr, 0, len - 1, Math.floor((len + 1) / 2)); // I am bad programmer :(

    // console.log("median slope");
    // console.log(median_slope);

    // let SMALL = new Array(pairs.length);
    // let EQUAL = new Array(pairs.length);
    // let LARGE = new Array(pairs.length);

    myConvexHull.push({ state: outputindex++, points: points, pairs: pairs, slope: median_slope, state: 'median_slope', noncandidates: null });
    textBoxEle.push("Now that we have the median slope of the pairs let's see if the median slope is the slope of the bridge edge To test we can sweep this line vertically.Based on this sweep we can determine if we have found k")
    let SMALL = [];
    let EQUAL = [];
    let LARGE = [];
    for (let i = 0; i &lt; pairs.length; i++) {
        let p1 = pairs[i][0];
        let p2 = pairs[i][1];
        let x1 = p1.x;
        let x2 = p2.x;
        let y1 = p1.y;
        let y2 = p2.y;

        if (x1 !== x2) {
            let slope = (y2 - y1) / (x2 - x1);
            if (slope === median_slope) {
                let curr_pair = [p1, p2];
                EQUAL.push(curr_pair);
            }
            else if (slope &lt; median_slope) {
                let curr_pair = [p1, p2];
                SMALL.push(curr_pair);
            }
            else if (slope > median_slope) {
                let curr_pair = [p1, p2];
                LARGE.push(curr_pair);
            }
        }
    }
    // // // console.log("SMALL", SMALL);
    // // // console.log("EQUAL", EQUAL);
    // // // console.log("LARGE", LARGE);
    // console.log("my tester");
    let max_c = -Infinity;
    for (let i = 0; i &lt; points.length; i++) {

        let x = points[i].x;
        let y = points[i].y;
        let curr_c = y - median_slope * x;

        if (curr_c > max_c) {
            max_c = curr_c;
        }

    }

    // // // console.log("smort pointer");
    let pmin = { x: Infinity, y: Infinity };
    let pmax = { x: -Infinity, y: -Infinity };
    for (let i = 0; i &lt; points.length; i++) {

        let x = points[i].x;
        let y = points[i].y;

        let curr_c = y - median_slope * x;

        if (Math.abs(curr_c - max_c) &lt; 0.001) {

            if (x &lt; pmin.x) {
                pmin = { x: x, y: y };
            }
            if (x > pmax.x) {
                pmax = { x: x, y: y };
            }
        }
    }
    if (pmin.x &lt;= median &amp;&amp; pmax.x > median) {
        let upper_bridge = [pmin, pmax];
        return upper_bridge;
    }
    else if (pmax.x &lt;= median) {
        for (let i = 0; i &lt; EQUAL.length; i++) {
            let pt = EQUAL[i][1];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; LARGE.length; i++) {
            let pt = LARGE[i][1];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; SMALL.length; i++) {
            let pt1 = SMALL[i][0];
            let pt2 = SMALL[i][1];
            candidates.push(pt1);
            candidates.push(pt2);
        }
        // changed
        // return get_lower_bridge(candidates, median);
    }
    else if (pmin.x > median) {
        for (let i = 0; i &lt; EQUAL.length; i++) {
            let pt = EQUAL[i][0];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; LARGE.length; i++) {
            let pt1 = LARGE[i][0];
            let pt2 = LARGE[i][1];
            candidates.push(pt1);
            candidates.push(pt2);
        }
        for (let i = 0; i &lt; SMALL.length; i++) {
            let pt = SMALL[i][0];
            candidates.push(pt);
        }
        // console.log("candidates");
        // console.log(candidates);
        // changed
    }
    let noncandidates = [];
    for (let i = 0; i &lt; points.length; i++) {
        let isCandidate = true;
        for (let j = 0; j &lt; candidates.length; j++) {
            if (Math.abs(candidates[j][0] - points[i].x) &lt; 0.0001 &amp;&amp; Math.abs(candidates[j][1] - points[i].y) &lt; 0.0001) {
                isCandidate = false;
                break;
            }
        }
        if (isCandidate) {
            noncandidates.push(points[i]);
        }
    }
    myConvexHull.push({ state: outputindex++, points: candidates, pairs: null, slope: null, state: 'points-removal', noncandidates: null });
    textBoxEle.push("We remove the non hull points by using median slope and Corollary of lemma2 + lemma 3 and then recursively calling function on remaining points to find lower hull")
    return get_lower_bridge(candidates, median);
}
/**
* The function `get_upper_bridge` in JavaScript sorts points, calculates median slope, and
* recursively finds the upper hull of a set of points.
* @param points - The `points` parameter in the `get_upper_bridge` function represents an array
* of points on a 2D plane. Each point is represented as an object with `x` and `y` coordinates.
* The function is designed to find the upper bridge of these points based on a given median value
* @param median - The code snippet you provided seems to be a function for finding the upper
* bridge in a set of points based on a given median value. The function recursively narrows down
* the points to find the upper bridge.
* @returns The function `get_upper_bridge` is returning the result of recursively calling itself
* with the `candidates` array and the `median` value. This recursive call is used to find the
* upper bridge of the given set of points. The function continues to remove non-hull points based
* on the median slope and certain conditions until it finds the upper bridge.
*/
function get_upper_bridge (points, median) {
    points.sort((a, b) => a.x &lt; b.x ? -1 : 1);
    console.log("Points lower bridge", points);
    if (points.length === 1) {
        return [points[0], points[0]];
    }
    let candidates = [];
    let pairs = [];

    if (points.length % 2 === 0) {
        for (let i = 0; i &lt; points.length; i += 2) {
            let first_pt = points[i];
            let second_pt = points[i];
            if (i + 1 !== points.length) {
                second_pt = points[i + 1];
            }
            let curr_pair = [first_pt, second_pt];
            pairs.push(curr_pair);
        }
    }
    else {
        candidates.push(points[0]);
        for (let i = 1; i &lt; points.length; i += 2) {
            let first_pt = points[i];
            let second_pt = points[i];
            if (i + 1 !== points.length) {
                second_pt = points[i + 1];
            }

            let curr_pair = [first_pt, second_pt];
            pairs.push(curr_pair);
        }
    }
    myConvexHull.push({ state: outputindex++, points: points, pairs: pairs, median_slope: null, state: 'pairs', noncandidates: null });
    textBoxEle.push("if we say your ideal edge has slope of k.we can try out different slopes and see this is they form bridge edge.let's start start drawing random edges between our points")


    let slopes_len = pairs.length;
    let slopes = [];
    // console.log("lower pairs", pairs);
    for (let i = 0; i &lt; pairs.length; i++) {
        let p1 = pairs[i][0];
        let p2 = pairs[i][1];
        let x1 = p1.x;
        let x2 = p2.x;
        let y1 = p1.y;
        let y2 = p2.y;

        if (x1 === x2) {
            if (y1 > y2) {
                candidates.push(p2);
            } else {
                candidates.push(p1);
            }
            slopes[i] = Infinity;
        }
        else {
            let slope = (y2 - y1) / (x2 - x1);
            slopes[i] = slope;
        }
    }
    // console.log("lower slopes : ", slopes);
    let arr = [];
    let len = 0;
    for (let i = 0; i &lt; slopes_len; i++) {
        if (slopes[i] !== Infinity) {
            arr[len++] = slopes[i];
        }
    }

    // if(len === 0)
    // {
    //     return Infinity, Infinity;
    // } // check....

    let median_slope;
    // console.log("len : ", len);
    // console.log("arr : ", arr);
    if (len === 1)
        median_slope = arr[0];
    else
        median_slope = kthSmallest(arr, 0, len - 1, Math.floor((len + 1) / 2));
    myConvexHull.push({ state: outputindex++, points: points, pairs: pairs, slope: median_slope, state: 'median_slope', noncandidates: null });
    textBoxEle.push("Now that we have the median slope of the pairs let's see if the median slope is the slope of the bridge edge To test we can sweep this line vertically.Based on this sweep we can determine if we have found k")

    let SMALL = [];
    let EQUAL = [];
    let LARGE = [];
    for (let i = 0; i &lt; pairs.length; i++) {
        let p1 = pairs[i][0];
        let p2 = pairs[i][1];
        let x1 = p1.x;
        let x2 = p2.x;
        let y1 = p1.y;
        let y2 = p2.y;
        if (x1 !== x2) {
            let slope = (y2 - y1) / (x2 - x1);
            // console.log("slope : ", slope);
            // console.log("median slope : ", median_slope);
            if (slope === median_slope) {
                let curr_pair = [p1, p2];
                EQUAL.push(curr_pair);
            }
            else if (slope &lt; median_slope) {
                let curr_pair = [p1, p2];
                SMALL.push(curr_pair);
            }
            else if (slope > median_slope) {
                let curr_pair = [p1, p2];
                LARGE.push(curr_pair);
            }
        }
    }
    let min_c = Infinity;

    for (let i = 0; i &lt; points.length; i++) {
        let x = points[i].x;
        let y = points[i].y;
        let curr_c = y - median_slope * x;
        if (curr_c &lt; min_c) {
            min_c = curr_c;
        }
    }
    // console.log("**** get lower bridge *****");
    let pmin = { x: Infinity, y: Infinity };
    let pmax = { x: -Infinity, y: -Infinity };
    for (let i = 0; i &lt; points.length; i++) {
        let x = points[i].x;
        let y = points[i].y;
        let curr_c = y - median_slope * x;
        if (Math.abs(curr_c - min_c) &lt; 0.001) {
            if (x &lt; pmin.x) {
                pmin = { x: x, y: y };
            }
            if (x > pmax.x) {
                pmax = { x: x, y: y };
            }
        }
    }
    // console.log("current equal", EQUAL);
    // console.log("current small", SMALL);
    // console.log("current large", LARGE);
    console.log("pmin : ", pmin);
    console.log("pmax : ", pmax);
    console.log("median : ", median);
    if (pmin.x &lt;= median &amp;&amp; pmax.x > median) {
        let lower_bridge = [pmin, pmax];
        // console.log("lower bridge : ", lower_bridge );
        return lower_bridge;
    }
    else if (pmax.x &lt;= median) {
        for (let i = 0; i &lt; EQUAL.length; i++) {
            let pt = EQUAL[i][1];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; LARGE.length; i++) {
            let pt1 = LARGE[i][0];
            let pt2 = LARGE[i][1];
            candidates.push(pt1);
            candidates.push(pt2);
        }
        for (let i = 0; i &lt; SMALL.length; i++) {
            let pt = SMALL[i][1];
            candidates.push(pt);
        }
        // console.log("candidates left here : ", candidates);
        // changed
    }
    else if (pmin.x > median) {
        for (let i = 0; i &lt; EQUAL.length; i++) {
            let pt = EQUAL[i][0];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; LARGE.length; i++) {
            let pt = LARGE[i][0];
            candidates.push(pt);
        }
        for (let i = 0; i &lt; SMALL.length; i++) {
            let pt1 = SMALL[i][0];
            let pt2 = SMALL[i][1];
            candidates.push(pt1);
            candidates.push(pt2);
        }
        // console.log("candidates left here : ", candidates);
        // changed
    }
    let noncandidates = [];
    for (let i = 0; i &lt; points.length; i++) {
        let isCandidate = true;
        for (let j = 0; j &lt; candidates.length; j++) {
            if (Math.abs(candidates[j][0] - points[i].x) &lt; 0.0001 &amp;&amp; Math.abs(candidates[j][1] - points[i].y) &lt; 0.0001) {
                isCandidate = false;
                break;
            }
        }
        if (isCandidate) {
            noncandidates.push(points[i]);
        }
    }
    myConvexHull.push({ state: outputindex++, points: candidates, pairs: null, slope: null, state: 'points-removal', noncandidates: null });
    textBoxEle.push("We remove the non hull points by using median slope and Corollary of lemma2 + lemma 3 and then recursively calling function on remaining points to find upper hull")

  
    return get_upper_bridge(candidates, median);
}
/**
* The function `get_lower_hull` calculates the lower hull of a set of points using the divide
* and conquer approach in computational geometry.
* @param pmin - It seems like you have shared a part of a code snippet for computing the lower
* hull in a convex hull algorithm. However, you have not provided the complete context or the
* definition of some functions like `kthSmallest`, `get_lower_bridge`, and `get_T`.
* @param pmax - It seems like the code snippet you provided is a part of a larger algorithm for
* computing the convex hull of a set of points. The `get_lower_hull` function is responsible for
* finding the lower hull of the points based on the given parameters.
* @param points - It seems like the code snippet you provided is part of a larger algorithm for
* computing the convex hull of a set of points. The `get_lower_hull` function is responsible for
* finding the lower hull of the points based on certain conditions.
* @returns The function `get_lower_hull` is returning the lower hull of a set of points. It
* recursively computes the lower hull by finding the bridge edge, splitting the points into left
* and right sets, and then recursively calling itself on the left and right sides of the bridge
* edge. The final result is the lower hull of the input points.
*/
function get_lower_hull  (pmin, pmax, points)  {
    // // console.log("get upper hull starts");
    let lower_hull = [];
    let n = points.length;
    let arr = [];
    for (let i = 0; i &lt; n; i++) {
        arr[i] = points[i].x;
    }

    let median;
    if (n === 1) {
        median = arr[0];
    }
    else {
        median = kthSmallest(arr, 0, n - 1, Math.floor((n + 1) / 2)); // yes I am stupid
    }

    myConvexHull.push({ state: outputindex++, points: points, pairs: null, slope: median, state: 'median_x', noncandidates: null });
    textBoxEle.push('With two sets being formed.We can find the bridge edge by connecting one hull point from left side to another hull point on the right side.The bridge edge will be part of our convex hull and it will merge our divided sets')

    // // console.log("Test");
    // // // console.log("median");
    // // // console.log(median); // correct till here
    // // console.log("computation for get upper bridge starts ");
    const lower_bridge = get_lower_bridge(points, median);
    // console.log("upper_bridge");
    // console.log(upper_bridge);

    myConvexHull.push({ state: outputindex++, points: points, pairs: lower_bridge, slope: null, state: 'lower_bridge', noncandidates: null });
    textBoxEle.push('We have found the bridge edge. Now recursively call the function on the left and right side of the bridge edge.')
    let pl = lower_bridge[0];
    let pr = lower_bridge[1];

    if (pl.x > pr.x) {
        let temp = pl;
        pl = pr;
        pr = temp;
    } // mai upper hull mai points sorted rakhna chahata hun
    lower_hull.push(pl);
    lower_hull.push(pr);

    if (pmin.x !== pl.x || pmin.y !== pl.y) // idk if pmin !== pl works
    {
        let lower_T_left = get_T(pmin, pl, points, false);
        let left = get_lower_hull(pmin, pl, lower_T_left);
        lower_hull = lower_hull.concat(left); // check don't know syntax
    }

    if (pmax.x !== pr.x || pmax.y !== pr.y) {
        let lower_T_right = get_T(pr, pmax, points, false);
        let right = get_lower_hull(pr, pmax, lower_T_right);
        lower_hull = lower_hull.concat(right);
    }
    // // console.log("upper_hull", upper_hull);
    myConvexHull.push({ state: outputindex++, points: points, pairs: lower_hull, slope: null, state: 'lower_hull', noncandidates: null });
    textBoxEle.push('We have found the lower hull. Now we can compute the remaining lower hull if the lower hull is done move on to compute upper hull')
    return lower_hull;
}

/**
* The function `get_upper_hull` calculates the upper hull of a set of points using the divide
* and conquer algorithm for finding the convex hull.
* @param pmin - The `pmin` parameter in the `get_upper_hull` function represents the minimum
* point on the x-axis among the input points. It is used to determine the starting point for
* constructing the upper hull of the convex hull.
* @param pmax - It seems like the description of the `pmax` parameter is missing in the
* provided code snippet. Could you please provide more information or context about what `pmax`
* represents in this function? This will help me assist you better in understanding the code.
* @param points - It seems like the description of the `points` parameter is missing in your
* code snippet. Could you please provide more information about what the `points` parameter
* represents in your `get_upper_hull` function? This will help me better understand the context
* and provide you with more accurate assistance.
* @returns The function `get_upper_hull` returns the upper hull of a set of points after
* performing certain calculations and recursive calls.
*/
function get_upper_hull()  {
    let upper_hull = [];
    let n = points.length;
    let arr = [];
    for (let i = 0; i &lt; n; i++) {
        arr[i] = points[i].x;
    }
    let median = n === 1 ? arr[0] : kthSmallest(arr, 0, n - 1, Math.floor((n + 1) / 2));
    myConvexHull.push({ state: outputindex++, points: points, pairs: null, slope: median, state: 'median_x', noncandidates: null });
    textBoxEle.push('With two sets being formed.We can find the bridge edge by connecting one hull point from left side to another hull point on the right side.The bridge edge will be part of our convex hull and it will merge our divided sets')

    // console.log("Hello");
    let upper_bridge = get_upper_bridge(points, median);
    // console.log("test1");
    let pl = upper_bridge[0];
    let pr = upper_bridge[1];
    // console.log("test2");


    myConvexHull.push({ state: outputindex++, points: points, pairs: upper_bridge, slope: null, state: 'lower_bridge', noncandidates: null });
    textBoxEle.push('We have found the bridge edge. Now recursively call the function on the left and right side of the bridge edge.')

    if (pl.x > pr.x) {
        let temp = pl;
        pl = pr;
        pr = temp;
    }

    upper_hull.push(pl);
    upper_hull.push(pr);

    if (pmin.x !== pl.x || pmin.y !== pl.y) {
        let upper_T_left = get_T(pmin, pl, points, true);
        let left = get_upper_hull(pmin, pl, upper_T_left);
        upper_hull = upper_hull.concat(left);
    }
    if (pmax.x !== pr.x || pmax.y !== pr.y) {
        let upper_T_right = get_T(pr, pmax, points, true);
        let right = get_upper_hull(pr, pmax, upper_T_right);
        upper_hull = upper_hull.concat(right);
    }
    // console.log("lower_hull", lower_hull);
    myConvexHull.push({ state: outputindex++, points: points, pairs: upper_hull, slope: null, state: 'upper_hull', noncandidates: null });
    textBoxEle.push('We have found the upper hull. Now we can compute the complete hull')


    return upper_hull;
}



/**
* The Canvas component in the JavaScript code allows users to interactively draw points on a canvas,
* visualize a convex hull algorithm, navigate through steps, and control the process using keyboard
* shortcuts.
* @returns The `Canvas` component is being returned. It contains a canvas element with various event
* handlers and functions to interact with the canvas, draw points, draw convex hull, handle mouse
* movements, add points, finish drawing, clear canvas, navigate through steps, and display steps in a
* text area. The component also includes buttons for navigation and interaction with the canvas.
*/</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Canvasvar.html">Canvasvar</a></li><li><a href="Ghost_complete.html">Ghost_complete</a></li><li><a href="Pacman_complete.html">Pacman_complete</a></li><li><a href="findConvexHull.html">findConvexHull</a></li></ul><h3>Classes</h3><ul><li><a href="ConvexHull.html">ConvexHull</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Canvas">Canvas</a></li><li><a href="global.html#Ghost">Ghost</a></li><li><a href="global.html#Pacman">Pacman</a></li><li><a href="global.html#colorList">colorList</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#draw_in_next">draw_in_next</a></li><li><a href="global.html#findHull">findHull</a></li><li><a href="global.html#findMedian">findMedian</a></li><li><a href="global.html#get_T">get_T</a></li><li><a href="global.html#get_lower_bridge">get_lower_bridge</a></li><li><a href="global.html#get_lower_hull">get_lower_hull</a></li><li><a href="global.html#get_upper_bridge">get_upper_bridge</a></li><li><a href="global.html#get_upper_hull">get_upper_hull</a></li><li><a href="global.html#kthSmallest">kthSmallest</a></li><li><a href="global.html#partition">partition</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Apr 02 2024 20:55:03 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
